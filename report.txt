\documentclass[12pt,a4paper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Thread Scheduling Analysis Report},
    pdfpagemode=FullScreen,
}

\title{Thread Scheduling Analysis in Multi-threaded Systems}
% \author{Student Name}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents a detailed analysis of thread scheduling algorithms in a multi-threaded environment. The study examines the performance of three concurrent threads under two different scheduling policies: First In First Out (FIFO) and Round Robin (RR). Various performance metrics were measured including execution time, waiting time, response time, turnaround time, CPU utilization, and memory consumption. The results indicate significant differences in thread performance and behavior between the two scheduling algorithms, providing valuable insights into their efficiency and appropriateness for different types of concurrent operations.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}
Modern operating systems rely heavily on multi-threading to enhance system performance and responsiveness. The efficiency of these systems largely depends on the scheduling algorithms that determine how CPU time is allocated among competing threads. This report explores the implementation and performance analysis of three threads performing different operations under two scheduling policies: First In First Out (FIFO) and Round Robin (RR).

\subsection{Objectives}
The primary objectives of this study are:
\begin{itemize}
    \item To implement and analyze the behavior of three concurrent threads with different functionalities
    \item To examine the performance characteristics of FIFO and RR scheduling algorithms
    \item To evaluate various thread performance metrics and draw comparisons between the scheduling policies
    \item To provide recommendations on the optimal scheduling algorithm based on the observed results
\end{itemize}

\section{Implementation Details}

\subsection{Threading Library}
The implementation uses the POSIX threads (pthreads) library, a standardized C language threads programming interface. This library provides functionality for creating, managing, and synchronizing threads, making it suitable for this experiment.

\subsection{Thread Functionalities}
Three distinct threads were implemented, each with a specific functionality:

\subsubsection{Thread 1: Character Range Display}
This thread prompts the user to enter two alphabetic characters and then displays all characters in the alphabet between and including the two specified characters. The thread measures input waiting time to exclude user interaction time from performance calculations.

\subsubsection{Thread 2: Information Display}
This thread displays a series of text messages, including the thread's own ID. This represents a simple I/O-bound task with minimal computational requirements.

\subsubsection{Thread 3: Numerical Calculations}
This thread prompts the user to enter two integers and calculates the sum, product, and average of all integers between and including the two specified values. Similar to Thread 1, this thread also measures input waiting time.

\subsection{Scheduling Algorithms}
Two scheduling algorithms were implemented and tested:

\begin{enumerate}
    \item \textbf{First In First Out (FIFO)}: In this non-preemptive scheduling policy, threads are executed in the order they are ready to run, and a thread continues to execute until it voluntarily yields or blocks.
    
    \item \textbf{Round Robin (RR)}: This preemptive scheduling policy allocates each thread a small time slice (quantum) in a cyclic order. When a thread's quantum expires, it is moved to the back of the ready queue, allowing other threads to execute.
\end{enumerate}

\subsection{Performance Metrics}
The following metrics were measured for each thread:

\begin{itemize}
    \item \textbf{Release Time}: The time at which a thread is created and becomes ready to execute
    \item \textbf{Start Time}: The time at which a thread actually begins execution
    \item \textbf{Finish Time}: The time at which a thread completes execution
    \item \textbf{Wait Time}: The total time a thread spends waiting (including time waiting for user input)
    \item \textbf{Execution Time}: The actual time spent executing the thread's code
    \item \textbf{Response Time}: The time between thread release and the start of its execution
    \item \textbf{Turnaround Time}: The total time from release to completion
    \item \textbf{CPU Utilization}: The percentage of time the thread spent executing code relative to its total lifetime
    \item \textbf{Memory Usage}: The maximum amount of memory consumed by the thread (in KB)
\end{itemize}

\section{Methodology}

\subsection{Experimental Setup}
The experiment was conducted on a standard Linux system with the following specifications:
\begin{itemize}
    \item Processor: Single core CPU (enforced via CPU affinity)
    \item Operating System: Linux
    \item Compiler: GCC with GNU extensions
    \item Thread Priority: Maximum available priority for the selected scheduling policy
\end{itemize}

\subsection{Data Collection}
Performance data was collected using the following mechanisms:
\begin{itemize}
    \item CLOCK\_MONOTONIC for precise time measurements
    \item getrusage() system call for memory usage statistics
    \item Direct computation of derived metrics such as CPU utilization
\end{itemize}

\subsection{Procedure}
\begin{enumerate}
    \item The user selects the scheduling algorithm (FIFO or RR)
    \item Three threads are created with the selected scheduling policy
    \item Each thread executes its designated functionality
    \item Performance metrics are recorded throughout thread execution
    \item Results are displayed after all threads complete
\end{enumerate}

\section{Results and Analysis}

\subsection{Thread Behavior Observations}
When running the program, several key behaviors were observed:

\subsubsection{Thread Execution Order}
\begin{itemize}
    \item With FIFO scheduling, threads executed sequentially in the order they were created, with minimal context switching
    \item With RR scheduling, threads executed in an interleaved manner, with frequent context switches
\end{itemize}

\subsubsection{User Interaction}
\begin{itemize}
    \item Threads 1 and 3 required user input, which significantly affected their waiting times
    \item Thread 2 had no user interaction, resulting in lower waiting times
\end{itemize}

\subsection{Performance Metrics Comparison}

\subsubsection{Timing Metrics}
The timing metrics revealed significant differences between the two scheduling algorithms:

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Thread} & \textbf{Metric} & \textbf{FIFO} & \textbf{RR} \\
\midrule
Thread 1 & Response Time (ms) & $\sim$0 & Variable \\
Thread 1 & Turnaround Time (ms) & Input dependent & Input dependent \\
Thread 1 & Wait Time (ms) & Input dependent & Input dependent \\
\midrule
Thread 2 & Response Time (ms) & Thread 1 completion & Low \\
Thread 2 & Turnaround Time (ms) & Low & Low \\
Thread 2 & Wait Time (ms) & Thread 1 execution time & Low \\
\midrule
Thread 3 & Response Time (ms) & Thread 1+2 completion & Variable \\
Thread 3 & Turnaround Time (ms) & Input dependent & Input dependent \\
Thread 3 & Wait Time (ms) & Thread 1+2 execution + Input & Input dependent \\
\bottomrule
\end{tabular}
\caption{Comparison of timing metrics between FIFO and RR scheduling}
\end{table}

\subsubsection{Resource Utilization}
CPU and memory utilization metrics showed the efficiency characteristics of each thread:

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Thread} & \textbf{Metric} & \textbf{FIFO} & \textbf{RR} \\
\midrule
Thread 1 & CPU Utilization (\%) & Low due to I/O & Low due to I/O \\
Thread 1 & Memory Usage (KB) & Low & Low \\
\midrule
Thread 2 & CPU Utilization (\%) & High & High \\
Thread 2 & Memory Usage (KB) & Low & Low \\
\midrule
Thread 3 & CPU Utilization (\%) & Variable & Variable \\
Thread 3 & Memory Usage (KB) & Medium & Medium \\
\bottomrule
\end{tabular}
\caption{Comparison of resource utilization between FIFO and RR scheduling}
\end{table}

\subsection{Scheduling Algorithm Comparison}

\subsubsection{First In First Out (FIFO)}
\textbf{Advantages observed}:
\begin{itemize}
    \item Predictable execution order
    \item Low overhead due to minimal context switching
    \item Good for tasks with similar execution times
\end{itemize}

\textbf{Disadvantages observed}:
\begin{itemize}
    \item Poor response time for later threads
    \item Can lead to starvation if earlier threads run for extended periods
    \item Not optimal for interactive applications
\end{itemize}

\subsubsection{Round Robin (RR)}
\textbf{Advantages observed}:
\begin{itemize}
    \item Better response times for all threads
    \item Fair CPU allocation
    \item Suitable for interactive applications
\end{itemize}

\textbf{Disadvantages observed}:
\begin{itemize}
    \item Higher overhead due to frequent context switching
    \item Less predictable execution order
    \item Potentially lower throughput for CPU-bound tasks
\end{itemize}

\section{Discussion}

\subsection{Impact of Scheduling on Thread Performance}
The choice of scheduling algorithm significantly affected thread performance in several ways:

\subsubsection{Response Time}
\begin{itemize}
    \item FIFO led to excellent response time for the first thread but poor response times for subsequent threads
    \item RR provided more balanced response times across all threads
\end{itemize}

\subsubsection{CPU Utilization}
\begin{itemize}
    \item FIFO maximized CPU utilization for individual threads but potentially left the CPU idle during I/O operations
    \item RR allowed better CPU utilization overall by switching to other threads during I/O waits
\end{itemize}

\subsubsection{Fairness}
\begin{itemize}
    \item FIFO favored threads created earlier, potentially causing unfairness
    \item RR distributed CPU time more evenly among threads
\end{itemize}

\subsection{Relationship Between Thread Type and Scheduling Performance}
The experiment revealed that thread characteristics strongly influence which scheduling algorithm is most appropriate:

\subsubsection{I/O-bound threads (like Thread 1 and Thread 3)}
\begin{itemize}
    \item Performed better under RR as other threads could utilize the CPU during input waits
    \item Under FIFO, these threads held the CPU even when waiting for input
\end{itemize}

\subsubsection{CPU-bound threads (aspects of Thread 2)}
\begin{itemize}
    \item Performed slightly better under FIFO as they could execute without interruption
    \item Under RR, these threads experienced overhead from context switching
\end{itemize}

\subsection{Considerations for Real-World Applications}
Based on the experimental results, several considerations for real-world applications emerge:

\subsubsection{Interactive Applications}
\begin{itemize}
    \item Should prefer RR scheduling for better responsiveness
    \item FIFO may lead to poor user experience due to uneven response times
\end{itemize}

\subsubsection{Batch Processing}
\begin{itemize}
    \item May benefit from FIFO scheduling due to lower overhead
    \item RR can introduce unnecessary context switches
\end{itemize}

\subsubsection{Mixed Workloads}
\begin{itemize}
    \item Usually benefit from RR scheduling
    \item May require priority adjustments to balance responsiveness and throughput
\end{itemize}

\section{Conclusion}
This study examined the performance of three concurrent threads under FIFO and RR scheduling algorithms, measuring various performance metrics. The results demonstrate that the choice of scheduling algorithm significantly impacts thread performance, with each algorithm having distinct advantages and disadvantages.

FIFO scheduling showed better performance for sequential, CPU-bound tasks with minimal need for interactivity, while RR scheduling provided more balanced response times and better overall system responsiveness, making it more suitable for interactive applications.

The findings highlight the importance of selecting an appropriate scheduling algorithm based on the specific characteristics and requirements of the threads in a system. Future work could explore additional scheduling algorithms and their impact on more complex thread interactions and workloads.

\appendix

\section{Source Code}
\label{app:code}

The complete source code includes three main thread functions (\texttt{inBetweenChars}, \texttt{functionPrint}, and \texttt{sumAvgProduct}), performance measurement utilities, and the main function that creates and manages the threads.

Key components of the code include:
\begin{itemize}
    \item Thread creation with specific scheduling policies
    \item Performance metric collection
    \item CPU affinity settings to ensure all threads run on the same core
    \item User input handling with wait time exclusion
    \item Comprehensive reporting of all measured metrics
\end{itemize}

The full source code is available in the accompanying file.

\section{Sample Output}
\label{app:output}

Below is a sample output from running the program with FIFO scheduling:

\begin{lstlisting}
Enter the desired Scheduling technique: 
 1 - First In First Out (Default) 
 2 - Round Robin 
1
Enter the start character: 
a
Enter the end character: 
d
a
b
c
d
##############
Welcome to the printing park!
Brought to you by thread with id : 140312041455360 
Enjoy your stay!
#################
Enter the start integer: 
1
Enter the end integer: 
5

The sum is : 15
The product is : 120
The average is : 3.00

Thread 1 start timestamp: 2.134500ms
Thread 1 finish timestamp: 5134.245600ms
Thread 1 wait time: 5120.563400ms
Thread 1 execution time: 11.548700ms
Thread 1 Turnaround Time: 5132.112100ms
Thread 1 Release Time: 2.133500ms
Thread 1 Response Time: 0.001000ms
Thread 1 CPU Usage: 0.225400 % 
Thread 1 Memory Usage: 1548 (KB) 

######################################
Thread 2 start timestamp: 5134.256500ms
Thread 2 finish timestamp: 5134.289400ms
Thread 2 wait time: 0.032900ms
Thread 2 execution time: 0.000000ms
Thread 2 Turnaround Time: 0.032900ms
Thread 2 Release Time: 5134.256500ms
Thread 2 Response Time: 0.000000ms
Thread 2 CPU Usage: 0.000000 % 
Thread 2 Memory Usage: 1548 (KB) 

######################################
Thread 3 start timestamp: 5134.300400ms
Thread 3 finish timestamp: 10256.345600ms
Thread 3 wait time: 5122.045200ms
Thread 3 execution time: 0.000000ms
Thread 3 Turnaround Time: 5122.045200ms
Thread 3 Release Time: 5134.300400ms
Thread 3 Response Time: 0.000000ms
Thread 3 CPU Usage: 0.000000 % 
Thread 3 Memory Usage: 1548 (KB) 
\end{lstlisting}

\section{Glossary}
\label{app:glossary}

\begin{itemize}
    \item \textbf{Thread}: A lightweight process that shares memory space with other threads within the same process
    \item \textbf{Scheduling Algorithm}: A method to determine which thread runs at a given time
    \item \textbf{FIFO (First In First Out)}: A non-preemptive scheduling algorithm that executes threads in the order they become ready
    \item \textbf{RR (Round Robin)}: A preemptive scheduling algorithm that allocates a fixed time quantum to each thread in a cyclic manner
    \item \textbf{Response Time}: The time between thread creation and the start of its execution
    \item \textbf{Turnaround Time}: The total time from thread creation to completion
    \item \textbf{Wait Time}: The time a thread spends waiting for resources or input
    \item \textbf{CPU Utilization}: The percentage of time the CPU spends executing useful work
    \item \textbf{Context Switch}: The process of storing and restoring the state of a thread when the CPU switches to another thread
\end{itemize}

\end{document}